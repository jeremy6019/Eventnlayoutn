package define;

public class awt {
/*
 
 ** GUI(Graphic User Interface- 아이콘이나 메소드 입력방식) Programming <-> CLI(Command Line Interface)- 명령어 입력방식 
   1.AWT - 운영체제의 자원을 빌려서 GUI를 표형 
  => 자원의 다양성에 한계가 있고 시스템이 느려지고 운영체제 별로 다르게 보입니다. 
  =>Swing의 대다수 컴포넌트들이 AWT클래스의 상속을 받음 
  =>이벤트 처리방식이 Swing과 Android에서 동일하게 적용 
  
  2.Swing - 	JVM(Java가 기본적으로 제공)의 자원을 빌려서 GUI를  표현 
  =>AWT보다는 컴포넌트가 다양하고 운영체제별로 동일하게 표현되며 시스템 자원을 사용하지 않기 때문에 AWT보다는
  성능이 좋음 
  => 디자인에 한계가 있음 
  
  3. Java F/X 
  =>JVM에서 제공하다가 별도로 제공하기도 함 
  =>Swing의 디자인 한계를 극복하고자 탄생 
  =>이벤트 처리방식이나 배치하는 방식이 Swing과 다름 
  =>안드로이드 할려고 할때 F/X를 하지 않음 
  
   4.Android 
   => 자신만의 별도의 컴포넌트들을 만들어서 사용 
   => 배치 방법이나 이벤트처리방법은 Swing과 유사 
   
   Java -> swing -> Android 
   Java -> Swing -> Thread -> Database -> android 
   Java -> Server Programming -> android 
   
   =>Java 대신에 Kotlin을 사용 
   
   ** 용어 
   1. Component - 화면에 배치되는 모든 것들을 Component 라고 합니다. 
   
   2. 	Control -	 화면에 배치되서 출력을 하던가 어떤 이벤트를 받아서 처리할 수 있는 Component 
  
   3. View - 화면에 출력되는 것 
   
   4. Container -여러 개를 배치할 수 있는 Component 
   => 단독으로 출력할 수 있는 것 - Window(Frame, Dialog 등) 
   => 단독으로 출력할 수 없는 것 - Panel, Layout(배치 방법, Container를 Layout이라고도 함 ) 
   
   5. Android는 Control을 widjet이라고 하기도 합니다. 
   
    ** CBD(Component Based Development) 
    => 컴퍼넌트 기반의 개발 방법론 
    => 자주 사용되는 것들을 Component로 미리 만들어 둔 후 조립해서 프로그래밍 
    
    ** AWT
    =>윈도우를 만들어서 컴포넌트들을 배치 
    1. Layout:배치방법 
    1) FlowLayout - Panel의 기본 배치방법으로 옆으로 계속해서 배치하고 공간이 없으면 아래로 배치 
    2) BorderLayout -Frame의 기본 배치방법으로 상하좌우 중앙에 배치하는 방법 
    =>Web이나 안드로이드에서 이와 유사한 배치방법을 많이 사용 
    => header, body, footer를 만들어서 사용하는 방법으로 많이 응용 
    3)GridLayout - 표 형태로 배치하는 방식 
    => 객체를 생성할 때 열 수 와 행 수를 입력해서 생성 
    => add메소드를 이용하면 순서대로 하나씩 배치 
    => 행이나 열이 부족하면 자동으로 늘어남 
    => 셀 크기에 맞게 컴포넌트의 크기가 조절됩니다. 
    
     4) CardLayout - 카드를 겹쳐 놓은 것 처럼 위에 쌓는 레이아웃 
     => next()라는 메소드를 이용해서 다음화면을 출력 
     
     5) Layout에 null을 대입하면 모든 컴포넌트들을 좌표와 크기를 입력해서 배치 
     => 권장하지는 않지만 컴포넌트를 움직이거나 크기 변화를 주고자 할 때는 사용 
     
   ** 이벤트 처리 
   =>Event: 사용자 또는 시스템이 발생시키는 사건 
   => 버튼을 누른다던가 윈도우가 종료된다던가 하는 것이 전부 이벤트 
   
   1.이벤트 처리 방식 
   1) 컴포넌트 자체가 가진 이벤트처리 메소드를 오버라이딩: 스마트폰 API에 존재하고 PC용 윈도우 프로그래밍에서는 드로윙 
    할 때 사용 
   
    2) Delegate패턴: 이벤트가 발생한 컴포넌트가 처리하는 것이 아니고 별도의 객체를 지정해서 메소드를 호출하는 방식 
    => 거의 모든 GUI프로그래밍에서 사용됩니다. 
    => AWT, Swing, f/X, Android, IOs,web등 거의 모든 프로그래밍 분야에서 사용하는 방식 
    
    3) Notification패턴: 이벤트 발생을 알려주어서 처리하는 방식 
    이벤트를 미리 만들어 두고 메소드만 구현하는 방식 
    
   2. AWT와 swing에서는 드로윙하는 경우를 제외하고는 전부 Delegate패턴을 사용 
   이벤트가 발생했을때 이벤트가 발생한 컴포넌트가 아니고 다른 객체가 이벤트를 처리하도록 합니다. 
   이렇게 하는 이유는 컴포넌트는 출력에만 관여하고 나머지 부분을 직접 처리하지 않도록 해서 유지보수를 
   편리하게 하기 위해서 입니다. 
   컴포넌트가 존재하는 경우 이 컴포넌트가 보여지는 설정과 이벤트처리를 모두 한다면 보여지는 부분만 수정하고자 할때 
   이벤트 처리하는 부분을 확인해야 합니다. 
   분리를 시키면 보여지는 설정을 변경할 때는 컴포넌트만 수정하고 이벤트 처리하는 부분을 수정하고자 하면 이벤트 
   처리 객체만 수정하면 되기 때문에 유지보수를 할 때 편리함 
   
   3. AWT에서의 이벤트 처리 
   
     1) 필요한 이벤트 처리를 위한 인터페이스를 구현한 클래스 또는 추상 클래스를 상속받은 클래스를 생성하고 이벤트 처리를 
     위한 메소드를 재정의   
     메소드 안에 이벤트가 발생했을떄 수행할 내용 작성 
     
     2) 이벤트가 발생하면 동작할 컴포넌트 객체가  .add이벤트 이Listener(1번에서 만든 클래스의 객체를 설정); 
      
     3) 컴포넌트에 이벤트가 발생하면 1번에서 만든 클래스의 메소드가 호출됩니다.   
   
   4. 모든 프로그래밍언어에서 이벤트처리 메소드의 첫번째 매개변수를 확인하면 이벤트가 발생한 객체를  알 수 있습니다. 
       어떤 언어에서는 이벤트 처리 객체를 바로 확인할 수 있고 어떤 언어에서는 그 안의 메소드나 속성을 호출해서 확인이 
       가능합니다.  
       
 ** ActionListener 
 =>버튼을 누르거나 체크박스 또는 라디오 버튼을 누를 때 그리고 텍스트필드에서 Enter를 누룰때 발생하는 이벤트 처리를 
    하기 위한 인터페이스 입니다.  
    
 ** 인터페이스의 구현 및 추상클래스의 상속 
 
 1.외부의 클래스를 만들어서 사용 
 
 2. 내부의 클래스를 만들어서 사용 
 
 3. 클래스를 만들지 않고 anonymous를 이용해서 사용 
 
  => 대부분의 자바나 안드로이드 교재에서는  2번이나 3번을 사용합니다. 
  클래스 내부에 만들면 인스턴스 변수 사용이 쉽기 때문에 2번이나 3번을 이용합니다. 
  MVC패턴의 근본적인 취지에는 맞지 않습니다. 
  책에서 이벤트 처리를 하는 부분이 있으면 1번의 형태로 변경해서 사용하는 것을 한번쯤은 해보는 것이 좋습니다. 
   
**Event Routing(최적의 경로를 찾는 방법) 
=> 하나의 객체가 여러 개의 객체의 이벤트 또는 여러 개의 이벤트를 처리하도록 하는 것 
=> 이벤트 처리 리스너의 메소드들의 첫번째 매개변수는 항상  이벤트가 발생한 객체에 대한 정보를 포함하고 있습니다. 
=> 자바의 AWT나 Swing에서는 getSource()를 호출하면 이벤트가 발생한 객체의 참조가 리턴됩니다. 
 이 참조를 이용하면 어떤 객체에게 이벤트가 발생했는지 확인할 수 있습니다. 
=>이벤트 처리를 할 때는 이벤트 처리 메소드의 매개변수들이 어떤 내용을 가지고 있는지 확인을 해야 합니다.  

**ActionEvent
=>getActionCommand() : 이벤트가 발생한 객체의 레이블을 문자열로 리턴 

**ItemListener 
=>Checkbox, Choice, List등에서 선택이 변경되었을 때 호출되는 이벤트를 처리하기 위한 리스너 
=>itemstateChanged메소드가 호출되는데 매개변수는 ItemEvent 
=>ItemEvent에는 getItem()이라는 메소드로 이벤트를 발생시킨 항목을 리턴해주고 getStateChange()메소드로 
어떤 상태로 변경되었는지 리턴해 줍니다. 
=>이 이벤트를 처리하는 경우는 드뭅니다. 
Checkbox나 Choice,List 등은 선택을 하고 다른 이벤트를 만났을 때 확인을 하는 경우가 많습니다. 

** 배열이나 List의 데이터 순회 
 1.인덱스를 이용해서 하나씩 가져오는 방법 
 for(int i=0; i<length 또는size(); i+=1 ){}
    배열[i] 또는 fltmxm.get(i);
 }
 
  2.빠른 열거를 이용하는 방법 
  for(하나의 자료형 임시변수: 배열이름이나 리스트이름){
   임시변수  
  } 
  
** String의 메소드 
length():길이를 정수로 리턴 
trim(): 좌우 공백을 제거하고 리턴 
charAt(int idx):idx번째 문자(char)를 리턴  

  toUpperCase()
  toLowerCase():모두 대문자나 소문자로 변환 
  아이디나 검색어 등은 모두 대문자나 소문자로 변환해서 처리- 대소문자 구분을 안합니다.
  
  indexOf(char또는 String):char 나 String이 발견되는 첫번쨰 위치를 리턴(못찾으면 음수)
  indexOf(char또는 string, int start)" start위치부터 검색 
  
  ** TextListener
  =>TextField나 TextArea에서 입력 내용이 변경될 때 처리를 위한 인터페이스 
  
   =>실습 
   텍스트 필드1개와 버튼을 화면에 배치 
   텍스트필드에 내용을 입력할 때마다 영문대소문,숫자,그외문자 개수를 세서 모두 1개 이상이 아니면
   배경색을 빨간색으로 하고 모두 1개이상이면 배경색을 녹색으로 변경 
   
   버튼을 눌렀을때 좌우공백을 제거하고 모두 대문자로 변경해서 콘솔에 출력하기 
   1997,0630이런데이터가 포함되어 있으면 비밀번호를 유추할 수 있는 패턴은 안됩니다. 라는 메세지를 콘솔에 출력 
   
   1. 화면을 생성 
   
   2. 텍스트필드의 이벤트 처리 (TextListener)
   
   3. 버튼이벤트 처리 (ActionListener) 
  
  
 
 */
}
